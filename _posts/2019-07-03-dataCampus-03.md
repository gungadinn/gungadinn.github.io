---
layout: post
title: "Python 고급 (1) - 함수형 기법"
date: 2019-07-03
excerpt: "빅데이터 청년인재 DAY 3"
tags: [python,빅데이터 청년인재,데이터청년캠퍼스,한국데이터진흥원]
comments: true


---



# Python 고급 (1) - 함수형 기법

함수형 패러다임 : 에서 mutable 없음. 바뀌면 골치아프니까 함수형 기법에서는 immutable 타입만 가지고 있다.

<br>

```python
# 절차적 프로그래밍
a = input()
a = int(a)   # output : 3
```

> 함수형 프로그래밍에서는 정의역을 한번에 처리하는 것에 더 효율적임
>
> 함수형 패러다임에서는 한꺼번에 처리하기 위해서는 한 개씩 뽑아내야 하기 때문에  처리한다.

<br>

```python
import time
def x(a=time.time):
    return a

time.time()
```

> output : 1971년 이후로 현재 시간까지 나노세컨드로 

멀티 패러다임 : 

객체지향언어를 기반으로 하지만 함수형 패러다임까지 지원

함수의 세트를 통해 흘러다니며. 함수의 입력으로부터 동작해서 출력을 만든다. 

<u>파이썬은 순수한 함수형 패러다임이 아니다. </u> 기본 객체지향의 함수형 패러다임을 지원을 한다. 때문에 함수형 패러다임에 집착할 필요가 없고 필요한 부분만 가져다 사용하면 된다.

 <br>

<br>

## 2.함수형 기법의 장점

---

### 1) 형식적 증명 가능성

중간에 값이 바뀌면 안되기 때문에 자료 형태가 mutable 형태이면 불가능하다. immutable만 가능.

<br>

### 2) 모듈성

프로그램을 작은 조각(함수)으로 분해할 수 있다. 작은 조각들을 잘 만들면 읽거나 오류 수정에 더 용이하고 다른 함수와 함성 시킬 수 있다.

<br>

### 3) 결합성

<br>

### 4) 디버깅과 테스트 용이성

<br>

<br>

## 3. 이터레이터 (Iterator)

---

이터레이터는 순환 가능한 객체로 전체 중에서 한 번에 한 개씩만 반환한다. 이터레이터는 next 함수 혹은 \__next__ 메소드를 통해 객체의 다음 요소를 반환한다. 

이터러블은 이터레이터를 얻을 수 있는 객체이다. `for X in Y` 에서 Y는 이터레이터여야 한다.

<br>

##### list_iterator

```python
a = [1, 2, 3]
b = iter(a)
type(b)   # output : list_iterator

next(b)   # output : 1
next(b)   # output : 2
next(b)   # output : 3
next(b)   # Error : StopIteration

b   # output : <list_iterator at 0x10e41aba8>
list(b)   # output : []
```

> StopIteration : Iterator에 의해 생성된 항목이 더이상 없다는 것을 알려주기 위해, 내장함수 next() 나 이터레이터의 \__next__ 메소드가 일으킨다.

![image-20190703130313561](/Users/eunkyoung/Library/Application Support/typora-user-images/image-20190703130313561.png)

<br>

```python
import dis

def iterator_exam():
    for i in [1, 2, 3]:
        print(i)
   
dis.dis(iterator_exam)
```

> output
>
> ![image-20190703132140965](/Users/eunkyoung/Library/Application Support/typora-user-images/image-20190703132140965.png)

<br>

##### set_iterator

```python
a = {1, 2, 3}
b = iter(a)
type(b)   # output : set_iterator

next(b)   # output : 1
```

<br>

##### str_iterator

```python
a = 'legolas'
b = iter(a)
b   # output : <str_iterator at 0x10e582588>

next(b)   # output : 'l'
list(b)   # output : ['e', 'g', 'o', 'l', 'a', 's']
type(b)   # output : str_iterator
```

<br>

```python
a = {1, 2, 3}
b = iter(a)
type(b)   # output : str_iterator

next(b)   # output : 1
next(b)   # output : 2
next(b)   # output : 3
next(b)   # Error : StopIteration

a = [1, 2, 3]
b = iter(a)
type(b)   # list_iterator
next(b)
list(b)   # outut : [2, 3])

a = [1, 2, 3]
b = iter(a)
next(b)   # output : [1]
next(b)   # output : [2, 3]
list(b)   # output : [3]
```

* 파이썬에서 이터레이터의 장점 : __Lazy__

  Lazy : 실행되기 전까지는 메모리 상에 안 올리고 실행되면 하나씩 메모리에 올려서 실행한다. 즉, 위의 예에서 next 할 때 하나씩 메모리에 올라간다. 이러한 방법은 속도가 느린데 파이썬에서는 Lazy의 속도를 올리기 위해 내부적으로 최적화가 되어있다. 따라서, python의 lazy 기법은 속도도 빠르다. 

<br>

* next는  pop하고 비슷하나 다르다. pop은 뒤에서부터 뽑는다면 next는 앞에서부터 뽑는다.

<br>

* 내부적으로 이터레이터로 바꾼다.





객체지향을 사용하기 위해서는 클래스를 선언하고 인스턴스화 한다.

인스턴스화 하려면 클래스 이름을 알아야한다.

객체지향은 인스턴스 방식으로 값을 만든다. 리터럴 방식도 지원.#

* 이터레이터 지원하는 데이터형 : 리스트, 튜플, 문자열, 딕셔너리, 집합

<br>

<br>

## 4. 제너레이터 (Generator)

---

```python
def generator_exam():
      yield 1
      yield 2
      yield 3
    
x = generator_exam()
type(x)   # output : generator

next(x)   # output : 1
next(x)   # output : 2
next(x)   # output : 3
next(x)   # StopIteration
```

— StopIteration

![image-20190703135234252](/Users/eunkyoung/Library/Application Support/typora-user-images/image-20190703135234252.png)



yield를 쓰면 이터레이터처럼 쓸 수 있는데 이터레이터는 이터러블만 쓸 수 있는데 일드는 제너레이터가 되는데 제너레이터는 내 마음대로 next 같은 것을 쓰게 한다. lazy한 장점이 있다.

```python
def generator_exam():
	  yield from [1, 2, 3, 4]
  
x = generator_exam()

next(x)   # output : 1
next(x)   # output : 2
next(x)   # output : 3
next(x)   # output : 4
next(x)   # StopIteration
```

— StopIteration![image-20190703140033729](/Users/eunkyoung/Library/Application Support/typora-user-images/image-20190703140033729.png)

<br>
<br>

## 5. 반복식

---

초기화하는데 유용하다.

<br>

### 1) 리스트 (List)

```python
[x for x in range(10)] 

[x+1 for x in range(10)]   

[x/3 for x in range(10)]

[str(x) for x in range(10)]

[0 for x in range(10)]
```

> output : [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
>
> output : [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
>
> output : [0.0, 0.3333333333333333, 0.6666666666666666, … , 3.0 ]
>
> output : ['0', '1', '2', '3,' '4', '5', '6', '7', '8', '9']
>
> output : [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]

<br>

> cf) for 안에 if를 쓰는 두 가지 방식
>
> 1. if를 뒤에 쓴다

### 2) 집합 (Set)

<br>

### 3) 딕셔너리 (Dictonary)

<br>

### 4) 튜플 ? (tuple)

<br>

<br>

## 6. First Class Funtion

---

파이썬에서 함수는 값이기 때문에 할당문에서 오른쪽에 쓸 수 있다.

> example 1

```python
a = print
a('legolas')   # output : legolas

a.__name__   # output : 'print' (실제로는 print지만 a로도 쓸 수 있다)
```

```python
printf = print
printf("hello world")   # output : hello world
```

<br>

> example 2

```python
sum = 0
sum + 1   # output : 1
del sum   # 만들었던 'sum = 0' 을 지운다
del sum   # NameError (함수 sum만 남았기 때문에 name 'sum'은 정의되지 않음)
```

<br>

> example 3 : 아래와 같은 예시에서는 더 이상 sum 함수를 사용하지 못한다.

```python
sum = 0
for i in range(1,101):
    sum+=i
    
sum    # output : 5050
```

<br>

> example 4 

```python
a = [str, int, float]
a[0]   # output : str
a[0](2)   # output : '2'
```

<br>

```python
def a(x):
    print(x())
  
a(print)   # output : None
```

<br>

<br>

## 7. 파이썬의 LEGB rule

---

변수 찾는 순서도 L → E → G → B이다.

<br>

### 1) L (LOCAL)

함수 내의 범위

```python
def y():
    x=1
    print(x)
  
y()   # output : 1
```

<br>

```python
def y():
    z=1
    print(z)

z   # NameError : 캡슐화
y.z = 3
y()   # output : 1
y.z   # output : 3
```

즉 z와 y.z는 다르다.

<br>

### 2) E (Enclosing function rule)

중첩 함수(nested function / 함수 안에 함수) 라면 그 밖에 있는 함수 범위

```python
def y():
    def z():
        return 1
    return z()

y()()   # output : 1
```

<br>

```python
def y():
    print('legolas')
        return y
  
  
y()   # output : legolas 
y()()   # output : legolas(\n)legolas
```

<br>

#### closure

```python
def y(x):
    def z():
        return 1
    return z

y(3)()   # output : 1

```

<br>

```python
def y(x):
    def z():
        return x+1
    return z

y(3)()    # output : 4
```

<br>

```python
def y(x):
    def z(n):
        return x+n
    return z


two_add = y(2)   
two_add(3)   # output : 3

two_add = y(4)
two_add(3)   # output : 7

#lambda 사용
def y(x):
    return lambda n:n+x

two_add = y(2)
two_add(4)
```

> 첫 번째 인자를 무엇으로 받느냐에 따라 두번째 인자를 전체적으로 바꿀 수 있다.

<br>

### 3) G (Global)

함수 밖을 일컫는 범위

```python
x = 1
def y():
  print(x)

y()   # output : 1
```

<br>

```python
x = 1   # 접근 할 수 있지만 변경은 불가
def y():
  x=x+1
  print(x)
  
y()    # UnBoundLocalError : 할당 전에 참조되기 때문에 에러
```

<br>

```python
x = 1
def y():
  global x   
  x=x+1
  print(x)
  
y()   # output : 2
y()   # output : 3
```

> global 선언 시 함수 안밖의 객체가 싱크된다.
>
> 즉 함수 내부에서 함수 외부의 것을 바꿀 수 없지만 global을 통해 싱크가 되어 바꿀 수 있다. 하지만 global을 사용하는 것은 안 좋다. 내가 생각하는 값이 있는데 global 객체가 있는 함수를 실행함으로써 값이 바뀔 수 있기 때문이다. 일종의 C언어의 goto 같은 존재이다. (python consenting adults)

<br>

### 4) B (Built-in)

내장 영역

<br>

<br>

## 에러정리

---

* StopIteration : Iterator에 의해 생성된 항목이 더이상 없다는 것을 알려주기 위해, 내장함수 next() 나 이터레이터의 _ _next__ 메소드가 일으킨다.

b : builtin